<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Background Remover</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .preview-grid { display: flex; gap: 40px; align-items: flex-start; margin-top: 30px; }
        .col { flex: 1; min-width: 0; }
        h2 { margin-top: 0; }
        img { max-width: 100%; border: 1px solid #ccc; border-radius:4px; background:#fff; }
        .download { margin-top: 10px; }
        .placeholder { padding: 40px; border:2px dashed #ccc; text-align:center; color:#777; font-size:14px; }
        @media (max-width: 900px){ .preview-grid { flex-direction: column; } }
    </style>
</head>
<body>
    <h1>Background Remover App</h1>
    <form method="POST" enctype="multipart/form-data" id="bgForm">
        <input type="file" name="image" id="imageInput" accept="image/*" required>
        <button type="submit">Remove Background</button>
    </form>
    <!-- Hidden instant preview image element reused inside Original column -->
    <img id="instantOriginalImg" src="#" alt="Selected Image Preview" style="display:none; max-width:100%; border:1px solid #ccc; border-radius:4px; background:#fff; margin-top:10px;" />
    <div class="preview-grid">
        <div class="col" id="col-original">
            <h2>Original</h2>
            {% if original_img %}
            <img src="{{ original_img }}" alt="Original Image" id="serverOriginalImg">
            {% else %}
            <div class="placeholder" id="originalPlaceholder">No image selected</div>
            {% endif %}
        </div>
        <div class="col" id="col-processed">
            <h2>Processed</h2>
            {% if preview_img %}
            <img src="{{ preview_img }}" alt="Processed Image" id="processedImg">
            <div id="adjustControls" style="margin-top:15px; background:#f5f5f5; padding:12px 14px; border:1px solid #ddd; border-radius:6px;">
                <div style="display:flex; gap:14px; flex-wrap:wrap;">
                    <label style="flex:1; min-width:160px;">Brightness
                        <input type="range" id="brightnessRange" min="0.2" max="2" step="0.05" value="1" style="width:100%;">
                    </label>
                    <label style="flex:1; min-width:160px;">Sharpness
                        <input type="range" id="sharpnessRange" min="0" max="3" step="0.1" value="1" style="width:100%;">
                    </label>
                </div>
                <div style="display:flex; gap:8px; margin-top:10px;">
                    <button type="button" id="resetAdjust" style="padding:6px 10px;">Reset</button>
                    <span id="adjustStatus" style="font-size:12px; color:#555; align-self:center;">Adjust the sliders</span>
                </div>
                <hr style="margin:14px -14px; border:none; border-top:1px solid #ddd;">
                <div style="display:flex; flex-direction:column; gap:10px;">
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                        <strong style="font-size:14px;">Background:</strong>
                        <div id="colorSwatches" style="display:flex; gap:6px; flex-wrap:wrap;">
                            <!-- common colors -->
                            <button type="button" class="swatch" data-color="#ffffff" style="width:26px;height:26px;border:1px solid #bbb;background:#ffffff;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#000000" style="width:26px;height:26px;border:1px solid #000;background:#000000;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#f44336" style="width:26px;height:26px;border:1px solid #c62828;background:#f44336;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#2196f3" style="width:26px;height:26px;border:1px solid #1565c0;background:#2196f3;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#4caf50" style="width:26px;height:26px;border:1px solid #2e7d32;background:#4caf50;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#ffeb3b" style="width:26px;height:26px;border:1px solid #f9a825;background:#ffeb3b;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#ff9800" style="width:26px;height:26px;border:1px solid #ef6c00;background:#ff9800;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#9c27b0" style="width:26px;height:26px;border:1px solid #6a0080;background:#9c27b0;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#00bcd4" style="width:26px;height:26px;border:1px solid #00838f;background:#00bcd4;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#eeeeee" style="width:26px;height:26px;border:1px solid #bdbdbd;background:#eeeeee;border-radius:4px;"></button>
                        </div>
                        <input type="color" id="customColor" value="#ffffff" title="Custom color" style="width:40px;height:32px;padding:0;border:1px solid #ccc;border-radius:4px;">
                        <button type="button" id="clearBg" style="padding:4px 8px;">Transparent</button>
                    </div>
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                        <label style="font-size:13px;">Upload BG Image <input type="file" id="bgImageInput" accept="image/*" style="font-size:12px;"></label>
                        <span id="bgUploadStatus" style="font-size:12px; color:#555;"></span>
                        <button type="button" id="removeBgImage" style="display:none; padding:4px 8px;">Remove BG Image</button>
                    </div>
                    <hr style="width:100%; border:none; border-top:1px solid #ddd; margin:4px 0;">
                    <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end;">
                        <div style="flex:2; min-width:180px;">
                            <label style="font-size:12px; display:block;">Text Overlay</label>
                            <input type="text" id="overlayText" placeholder="Enter text" style="width:100%; padding:4px 6px;">
                        </div>
                        <div style="flex:1; min-width:90px;">
                            <label style="font-size:12px; display:block;">Size</label>
                            <input type="number" id="textSize" value="48" min="8" max="400" style="width:100%; padding:4px 6px;">
                        </div>
                        <div style="flex:1; min-width:110px;">
                            <label style="font-size:12px; display:block;">Color</label>
                            <input type="color" id="textColor" value="#000000" style="width:100%; height:32px; padding:0;">
                        </div>
                        <div style="flex:1; min-width:120px;">
                            <label style="font-size:12px; display:block;">Position</label>
                            <select id="textPos" style="width:100%; padding:4px 6px;">
                                <option value="bc">Bottom Center</option>
                                <option value="bl">Bottom Left</option>
                                <option value="br">Bottom Right</option>
                                <option value="tc">Top Center</option>
                                <option value="tl">Top Left</option>
                                <option value="tr">Top Right</option>
                                <option value="cc">Center</option>
                                <option value="cl">Center Left</option>
                                <option value="cr">Center Right</option>
                            </select>
                        </div>
                        <div style="flex:1; min-width:70px; display:flex; align-items:center; gap:4px;">
                            <input type="checkbox" id="textBold">
                            <label for="textBold" style="font-size:12px;">Bold</label>
                        </div>
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
                        <div style="flex:1; min-width:160px;">
                            <label style="font-size:12px; display:block;">Rotate (deg)</label>
                            <input type="range" id="rotateRange" min="0" max="360" step="1" value="0" style="width:100%;">
                        </div>
                        <div style="display:flex; gap:6px; align-items:center;">
                            <label style="font-size:12px;">Flip:</label>
                            <button type="button" id="flipH" style="padding:4px 6px;">H</button>
                            <button type="button" id="flipV" style="padding:4px 6px;">V</button>
                            <button type="button" id="flipReset" style="padding:4px 6px;">Reset</button>
                        </div>
                        <span id="rotateValue" style="font-size:12px; color:#555;">0°</span>
                    </div>
                </div>
            </div>
            <div class="download">
                <a id="downloadProcessed" href="{{ download_link }}" download>Download PNG</a>
            </div>
            {% else %}
            <div class="placeholder" id="processedPlaceholder">Process to see result</div>
            {% endif %}
        </div>
    </div>
<script>
const fileInput = document.getElementById('imageInput');
const instantImg = document.getElementById('instantOriginalImg');
const originalCol = document.getElementById('col-original');
const originalPlaceholder = document.getElementById('originalPlaceholder');
const processedCol = document.getElementById('col-processed');
const processedImgEl = document.getElementById('processedImg');
const brightnessRange = document.getElementById('brightnessRange');
const sharpnessRange = document.getElementById('sharpnessRange');
const adjustStatus = document.getElementById('adjustStatus');
const resetAdjust = document.getElementById('resetAdjust');
const resultFileName = "{{ result_filename if result_filename else '' }}";
const downloadProcessed = document.getElementById('downloadProcessed');
const swatches = document.querySelectorAll('.swatch');
const customColor = document.getElementById('customColor');
const clearBgBtn = document.getElementById('clearBg');
const bgImageInput = document.getElementById('bgImageInput');
const bgUploadStatus = document.getElementById('bgUploadStatus');
const removeBgImageBtn = document.getElementById('removeBgImage');
let currentBgColor = '';
let currentBgImage = '';
// Text & transform controls
const overlayText = document.getElementById('overlayText');
const textSize = document.getElementById('textSize');
const textColor = document.getElementById('textColor');
const textPos = document.getElementById('textPos');
const textBold = document.getElementById('textBold');
const rotateRange = document.getElementById('rotateRange');
const rotateValue = document.getElementById('rotateValue');
const flipH = document.getElementById('flipH');
const flipV = document.getElementById('flipV');
const flipReset = document.getElementById('flipReset');
let flipStateH = false;
let flipStateV = false;

async function fetchAdjusted(){
    if(!processedImgEl || !resultFileName) return;
    const b = brightnessRange.value;
    const s = sharpnessRange.value;
    adjustStatus.textContent = 'Applying…';
    const baseEndpoint = (currentBgColor || currentBgImage || (overlayText && overlayText.value.trim()) || (rotateRange && rotateRange.value !== '0') || (flipStateH || flipStateV)) ? '/render' : '/adjust';
    let url = `${baseEndpoint}?file=${encodeURIComponent(resultFileName)}&brightness=${b}&sharpness=${s}`;
    if(currentBgColor){
        url += `&color=${encodeURIComponent(currentBgColor.replace('#',''))}`;
    }
    if(currentBgImage){
        url += `&bg_image=${encodeURIComponent(currentBgImage)}`;
    }
    if(overlayText && overlayText.value.trim()){
        url += `&text=${encodeURIComponent(overlayText.value.trim())}`;
        url += `&text_size=${encodeURIComponent(textSize.value || '48')}`;
        url += `&text_color=${encodeURIComponent(textColor.value.replace('#',''))}`;
        url += `&text_pos=${encodeURIComponent(textPos.value)}`;
        if(textBold.checked) url += `&text_bold=1`;
    }
    if(rotateRange && rotateRange.value !== '0'){
        url += `&rotate=${encodeURIComponent(rotateRange.value)}`;
    }
    let flipParam = '';
    if(flipStateH) flipParam += 'h';
    if(flipStateV) flipParam += 'v';
    if(flipParam) url += `&flip=${flipParam}`;
    try {
        const resp = await fetch(url);
        if(!resp.ok) throw new Error('HTTP '+resp.status);
        const blob = await resp.blob();
        const objURL = URL.createObjectURL(blob);
        processedImgEl.src = objURL;
        adjustStatus.textContent = `B ${b} | S ${s}` + (currentBgColor ? ` | BG color` : (currentBgImage ? ' | BG image' : ''));
    } catch(err){
        adjustStatus.textContent = 'Error: '+err.message;
    }
}

if (brightnessRange && sharpnessRange){
    let debounceTimer;
    const handler = () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(fetchAdjusted, 180);
    };
    brightnessRange.addEventListener('input', handler);
    sharpnessRange.addEventListener('input', handler);
}

if (resetAdjust){
    resetAdjust.addEventListener('click', () => {
        if(!brightnessRange || !sharpnessRange) return;
        brightnessRange.value = 1;
        sharpnessRange.value = 1;
    currentBgColor = '';
    currentBgImage = '';
    removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
}

function ensurePlaceholder(col, id, text){
    let el = document.getElementById(id);
    if(!el){
        el = document.createElement('div');
        el.id = id;
        el.className = 'placeholder';
        el.textContent = text;
        col.appendChild(el);
    } else {
        el.style.display='block';
    }
}

function resetForNewSelection(){
    // Remove server original image
    const serverOriginal = document.getElementById('serverOriginalImg');
    if(serverOriginal) serverOriginal.remove();
    // Remove processed image & download link
    const processedImg = document.getElementById('processedImg');
    if(processedImg) processedImg.remove();
    const downloadLinkWrapper = processedCol.querySelector('.download');
    if(downloadLinkWrapper) downloadLinkWrapper.remove();
    // Recreate / show placeholders
    ensurePlaceholder(originalCol, 'originalPlaceholder', 'No image selected');
    ensurePlaceholder(processedCol, 'processedPlaceholder', 'Process to see result');
    // Hide instant preview until change event loads new image
    instantImg.style.display='none';
}

fileInput.addEventListener('change', function(){
    const file = this.files && this.files[0];
    if(!file){ instantImg.style.display='none'; return; }
    const reader = new FileReader();
    reader.onload = e => {
        instantImg.src = e.target.result;
        instantImg.style.display = 'block';
        if (originalPlaceholder) originalPlaceholder.remove();
        if (!originalCol.querySelector('#instantOriginalImg')) {
            originalCol.appendChild(instantImg);
        }
    };
    reader.readAsDataURL(file);
});

// Reset everything on click (before file chooser opens)
fileInput.addEventListener('click', resetForNewSelection);

// Hide instant preview if a server-rendered Original Image exists
if (document.querySelector('img[alt="Original Image"]')) {
    instantImg.style.display='none';
}

// Enable downloading the currently adjusted version instead of the original processed file
if (downloadProcessed && processedImgEl){
    downloadProcessed.addEventListener('click', async (e) => {
        if(!resultFileName || !brightnessRange || !sharpnessRange) return; // fallback to normal href
        e.preventDefault();
        // Fetch current adjusted image (ensuring latest slider values are applied)
        const b = brightnessRange.value;
        const s = sharpnessRange.value;
        const baseEndpoint = (currentBgColor || currentBgImage || (overlayText && overlayText.value.trim()) || (rotateRange && rotateRange.value !== '0') || (flipStateH || flipStateV)) ? '/render' : '/adjust';
        let url = `${baseEndpoint}?file=${encodeURIComponent(resultFileName)}&brightness=${b}&sharpness=${s}`;
        if(currentBgColor){
            url += `&color=${encodeURIComponent(currentBgColor.replace('#',''))}`;
        }
        if(currentBgImage){
            url += `&bg_image=${encodeURIComponent(currentBgImage)}`;
        }
        if(overlayText && overlayText.value.trim()){
            url += `&text=${encodeURIComponent(overlayText.value.trim())}`;
            url += `&text_size=${encodeURIComponent(textSize.value || '48')}`;
            url += `&text_color=${encodeURIComponent(textColor.value.replace('#',''))}`;
            url += `&text_pos=${encodeURIComponent(textPos.value)}`;
            if(textBold.checked) url += `&text_bold=1`;
        }
        if(rotateRange && rotateRange.value !== '0'){
            url += `&rotate=${encodeURIComponent(rotateRange.value)}`;
        }
        let flipParam = '';
        if(flipStateH) flipParam += 'h';
        if(flipStateV) flipParam += 'v';
        if(flipParam) url += `&flip=${flipParam}`;
        try {
            const resp = await fetch(url);
            if(!resp.ok) throw new Error('HTTP '+resp.status);
            const blob = await resp.blob();
            const a = document.createElement('a');
            const objectUrl = URL.createObjectURL(blob);
            a.href = objectUrl;
            const base = resultFileName.replace(/\.png$/i,'');
            const bSan = b.replace(/[^0-9.]/g,'');
            const sSan = s.replace(/[^0-9.]/g,'');
            const bgTag = currentBgColor ? `_bg${currentBgColor.replace('#','')}` : (currentBgImage ? `_bgimg` : '');
            let textTag = overlayText && overlayText.value.trim() ? '_txt' : '';
            let rotTag = rotateRange && rotateRange.value !== '0' ? `_r${rotateRange.value}` : '';
            let flipTag = flipParam ? `_f${flipParam}` : '';
            a.download = `${base}_b${bSan}_s${sSan}${bgTag}${textTag}${rotTag}${flipTag}.png`;
            document.body.appendChild(a);
            a.click();
            setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); }, 1500);
        } catch(err){
            console.error('Download failed', err);
        }
    });
}

// Background color swatches
swatches.forEach(btn => {
    btn.addEventListener('click', () => {
        currentBgColor = btn.getAttribute('data-color');
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
});

if(customColor){
    customColor.addEventListener('input', () => {
        currentBgColor = customColor.value;
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
}

if(clearBgBtn){
    clearBgBtn.addEventListener('click', () => {
        currentBgColor = '';
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        if(overlayText) overlayText.value='';
        if(textSize) textSize.value='48';
        if(textColor) textColor.value='#000000';
        if(textPos) textPos.value='bc';
        if(textBold) textBold.checked=false;
        if(rotateRange){ rotateRange.value=0; rotateValue.textContent='0°'; }
        flipStateH=false; flipStateV=false;
        fetchAdjusted();
    });
}

// Upload custom background image
if(bgImageInput){
    bgImageInput.addEventListener('change', async () => {
        const file = bgImageInput.files && bgImageInput.files[0];
        if(!file) return;
        const formData = new FormData();
        formData.append('bg', file);
        bgUploadStatus.textContent = 'Uploading...';
        try {
            const resp = await fetch('/upload_bg', { method: 'POST', body: formData });
            const data = await resp.json();
            if(!resp.ok){
                throw new Error(data.error || resp.status);
            }
            currentBgImage = data.filename;
            currentBgColor = '';
            removeBgImageBtn.style.display='inline-block';
            bgUploadStatus.textContent = 'BG image set';
            fetchAdjusted();
        } catch(err){
            bgUploadStatus.textContent = 'Error';
            console.error(err);
        }
    });
}

if(removeBgImageBtn){
    removeBgImageBtn.addEventListener('click', () => {
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
}

// Text & transform listeners
const textInputs = [overlayText, textSize, textColor, textPos, textBold];
textInputs.forEach(el => {
    if(!el) return;
    const evt = (el.type === 'text' || el.tagName === 'SELECT' || el.type === 'number') ? 'input' : 'change';
    el.addEventListener(evt, () => {
        fetchAdjusted();
    });
});

if(rotateRange){
    rotateRange.addEventListener('input', () => {
        rotateValue.textContent = rotateRange.value + '°';
        fetchAdjusted();
    });
}

if(flipH){
    flipH.addEventListener('click', () => { flipStateH = !flipStateH; fetchAdjusted(); });
}
if(flipV){
    flipV.addEventListener('click', () => { flipStateV = !flipStateV; fetchAdjusted(); });
}
if(flipReset){
    flipReset.addEventListener('click', () => { flipStateH=false; flipStateV=false; fetchAdjusted(); });
}
</script>
</body>
</html>
