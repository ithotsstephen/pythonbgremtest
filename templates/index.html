<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Background Remover</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .preview-grid { display: flex; gap: 40px; align-items: flex-start; margin-top: 30px; }
        .col { flex: 1; min-width: 0; }
        h2 { margin-top: 0; }
        img { max-width: 100%; border: 1px solid #ccc; border-radius:4px; background:#fff; }
        .download { margin-top: 10px; }
        .placeholder { padding: 40px; border:2px dashed #ccc; text-align:center; color:#777; font-size:14px; }
        @media (max-width: 900px){ .preview-grid { flex-direction: column; } }
    </style>
</head>
<body>
    <h1>Background Remover App</h1>
    <form method="POST" enctype="multipart/form-data" id="bgForm">
        <input type="file" name="image" id="imageInput" accept="image/*" required>
        <button type="submit">Remove Background</button>
    </form>
    <!-- Hidden instant preview image element reused inside Original column -->
    <img id="instantOriginalImg" src="#" alt="Selected Image Preview" style="display:none; max-width:100%; border:1px solid #ccc; border-radius:4px; background:#fff; margin-top:10px;" />
    <div class="preview-grid">
        <div class="col" id="col-original">
            <h2>Original</h2>
            {% if original_img %}
            <img src="{{ original_img }}" alt="Original Image" id="serverOriginalImg">
            {% else %}
            <div class="placeholder" id="originalPlaceholder">No image selected</div>
            {% endif %}
        </div>
        <div class="col" id="col-processed">
            <h2>Processed</h2>
            {% if preview_img %}
            <img src="{{ preview_img }}" alt="Processed Image" id="processedImg">
                <div id="processedWrapper" style="position:relative; display:inline-block;">
                    <!-- Draggable overlay text element inserted dynamically -->
                </div>
            <div id="textDragLayer" style="position:relative;">
                <!-- dynamic draggable text preview inserted here -->
            </div>
            <div id="adjustControls" style="margin-top:15px; background:#f5f5f5; padding:12px 14px; border:1px solid #ddd; border-radius:6px;">
                <div style="display:flex; gap:14px; flex-wrap:wrap;">
                    <label style="flex:1; min-width:160px;">Brightness
                        <input type="range" id="brightnessRange" min="0.2" max="2" step="0.05" value="1" style="width:100%;">
                    </label>
                    <label style="flex:1; min-width:160px;">Sharpness
                        <input type="range" id="sharpnessRange" min="0" max="3" step="0.1" value="1" style="width:100%;">
                    </label>
                </div>
                <div style="display:flex; gap:8px; margin-top:10px;">
                    <button type="button" id="resetAdjust" style="padding:6px 10px;">Reset</button>
                    <span id="adjustStatus" style="font-size:12px; color:#555; align-self:center;">Adjust the sliders</span>
                </div>
                <hr style="margin:14px -14px; border:none; border-top:1px solid #ddd;">
                <div style="display:flex; flex-direction:column; gap:10px;">
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                        <strong style="font-size:14px;">Background:</strong>
                        <div id="colorSwatches" style="display:flex; gap:6px; flex-wrap:wrap;">
                            <!-- common colors -->
                            <button type="button" class="swatch" data-color="#ffffff" style="width:26px;height:26px;border:1px solid #bbb;background:#ffffff;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#000000" style="width:26px;height:26px;border:1px solid #000;background:#000000;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#f44336" style="width:26px;height:26px;border:1px solid #c62828;background:#f44336;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#2196f3" style="width:26px;height:26px;border:1px solid #1565c0;background:#2196f3;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#4caf50" style="width:26px;height:26px;border:1px solid #2e7d32;background:#4caf50;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#ffeb3b" style="width:26px;height:26px;border:1px solid #f9a825;background:#ffeb3b;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#ff9800" style="width:26px;height:26px;border:1px solid #ef6c00;background:#ff9800;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#9c27b0" style="width:26px;height:26px;border:1px solid #6a0080;background:#9c27b0;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#00bcd4" style="width:26px;height:26px;border:1px solid #00838f;background:#00bcd4;border-radius:4px;"></button>
                            <button type="button" class="swatch" data-color="#eeeeee" style="width:26px;height:26px;border:1px solid #bdbdbd;background:#eeeeee;border-radius:4px;"></button>
                        </div>
                        <input type="color" id="customColor" value="#ffffff" title="Custom color" style="width:40px;height:32px;padding:0;border:1px solid #ccc;border-radius:4px;">
                        <button type="button" id="clearBg" style="padding:4px 8px;">Transparent</button>
                    </div>
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                        <label style="font-size:13px;">Upload BG Image <input type="file" id="bgImageInput" accept="image/*" style="font-size:12px;"></label>
                        <span id="bgUploadStatus" style="font-size:12px; color:#555;"></span>
                        <button type="button" id="removeBgImage" style="display:none; padding:4px 8px;">Remove BG Image</button>
                    </div>
                    <hr style="width:100%; border:none; border-top:1px solid #ddd; margin:4px 0;">
                    <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end;">
                        <div style="flex:2; min-width:180px;">
                            <label style="font-size:12px; display:block;">Text Overlay (multi-line)</label>
                            <textarea id="overlayText" placeholder="Enter description" rows="3" style="width:100%; padding:4px 6px; resize:horizontal; line-height:1.25; font-family:inherit;"></textarea>
                            <small style="font-size:11px; color:#555; display:block; margin-top:2px;">Resize width then drag text on image. Editing text resets position.</small>
                        </div>
                        <div style="flex:1; min-width:90px;">
                            <label style="font-size:12px; display:block;">Size</label>
                            <input type="number" id="textSize" value="48" min="8" max="400" style="width:100%; padding:4px 6px;">
                        </div>
                        <div style="flex:1; min-width:110px;">
                            <label style="font-size:12px; display:block;">Color</label>
                            <input type="color" id="textColor" value="#000000" style="width:100%; height:32px; padding:0;">
                        </div>
                        <div style="flex:1; min-width:120px;">
                            <label style="font-size:12px; display:block;">Position</label>
                            <select id="textPos" style="width:100%; padding:4px 6px;">
                                <option value="bc">Bottom Center</option>
                                <option value="bl">Bottom Left</option>
                                <option value="br">Bottom Right</option>
                                <option value="tc">Top Center</option>
                                <option value="tl">Top Left</option>
                                <option value="tr">Top Right</option>
                                <option value="cc">Center</option>
                                <option value="cl">Center Left</option>
                                <option value="cr">Center Right</option>
                            </select>
                        </div>
                        <div style="flex:1; min-width:70px; display:flex; align-items:center; gap:4px;">
                            <input type="checkbox" id="textBold">
                            <label for="textBold" style="font-size:12px;">Bold</label>
                        </div>
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
                        <div style="flex:1; min-width:160px;">
                            <label style="font-size:12px; display:block;">Rotate (deg)</label>
                            <input type="range" id="rotateRange" min="0" max="360" step="1" value="0" style="width:100%;">
                        </div>
                                            <div style="flex:1; min-width:160px;">
                                                <label style="font-size:12px; display:block;">Text Rotate</label>
                                                <input type="range" id="textRotateRange" min="0" max="360" step="1" value="0" style="width:100%;">
                                            </div>
                        <div style="display:flex; gap:6px; align-items:center;">
                            <label style="font-size:12px;">Flip:</label>
                            <button type="button" id="flipH" style="padding:4px 6px;">H</button>
                            <button type="button" id="flipV" style="padding:4px 6px;">V</button>
                            <button type="button" id="flipReset" style="padding:4px 6px;">Reset</button>
                        </div>
                        <span id="rotateValue" style="font-size:12px; color:#555;">0°</span>
                    </div>
                    <hr style="width:100%; border:none; border-top:1px solid #ddd; margin:4px 0;">
                    <div style="display:flex; flex-direction:column; gap:6px;">
                        <strong style="font-size:13px;">Social Resize (select sizes)</strong>
                        <div style="display:flex; flex-wrap:wrap; gap:10px; font-size:12px;">
                            <label><input type="checkbox" class="sizeOpt" value="ig_square"> IG Square 1080x1080</label>
                            <label><input type="checkbox" class="sizeOpt" value="ig_portrait"> IG Portrait 1080x1350</label>
                            <label><input type="checkbox" class="sizeOpt" value="ig_landscape"> IG Landscape 1080x566</label>
                            <label><input type="checkbox" class="sizeOpt" value="fb_post"> Facebook Post 1200x630</label>
                            <label><input type="checkbox" class="sizeOpt" value="li_post"> LinkedIn Post 1200x627</label>
                            <label><input type="checkbox" class="sizeOpt" value="x_post"> X Post 1600x900</label>
                        </div>
                        <div style="display:flex; flex-wrap:wrap; gap:14px; font-size:12px; align-items:center;">
                            <div>
                                <label style="display:block; font-size:11px;">Fit Mode</label>
                                <select id="resizeMode" style="font-size:12px; padding:2px 4px;">
                                    <option value="fit">Fit (contain, pad)</option>
                                    <option value="cover">Cover (crop overflow)</option>
                                </select>
                            </div>
                            <div>
                                <label style="display:block; font-size:11px;">Pad Color</label>
                                <input type="color" id="padColor" value="#000000" style="width:40px; height:32px; padding:0;">
                            </div>
                            <label style="display:flex; gap:4px; align-items:center; margin-top:14px;">
                                <input type="checkbox" id="usePadColor"> Fill Padding
                            </label>
                        </div>
                        <div style="display:flex; gap:8px; align-items:center;">
                            <button type="button" id="downloadSelectedSizes" style="padding:6px 10px;">Download Selected Sizes (ZIP)</button>
                            <span id="multiSizeStatus" style="font-size:11px; color:#555;"></span>
                        </div>
                        <small style="font-size:11px; color:#666;">Maintains aspect ratio with transparent padding.</small>
                    </div>
                </div>
            </div>
            <div class="download">
                <a id="downloadProcessed" href="{{ download_link }}" download>Download PNG</a>
            </div>
            {% else %}
            <div class="placeholder" id="processedPlaceholder">Process to see result</div>
            {% endif %}
        </div>
    </div>
<script>
const fileInput = document.getElementById('imageInput');
const instantImg = document.getElementById('instantOriginalImg');
const originalCol = document.getElementById('col-original');
const originalPlaceholder = document.getElementById('originalPlaceholder');
const processedCol = document.getElementById('col-processed');
const processedImgEl = document.getElementById('processedImg');
const brightnessRange = document.getElementById('brightnessRange');
const sharpnessRange = document.getElementById('sharpnessRange');
const adjustStatus = document.getElementById('adjustStatus');
const resetAdjust = document.getElementById('resetAdjust');
const resultFileName = "{{ result_filename if result_filename else '' }}";
const downloadProcessed = document.getElementById('downloadProcessed');
const swatches = document.querySelectorAll('.swatch');
const customColor = document.getElementById('customColor');
const clearBgBtn = document.getElementById('clearBg');
const bgImageInput = document.getElementById('bgImageInput');
const bgUploadStatus = document.getElementById('bgUploadStatus');
const removeBgImageBtn = document.getElementById('removeBgImage');
let currentBgColor = '';
let currentBgImage = '';
// Drag text state
let dragTextEl = null;
let dragging = false;
let dragOffsetX = 0;
let dragOffsetY = 0;
let textAbsX = null; // absolute pixel positions stored
let textAbsY = null;
// Text & transform controls
const overlayText = document.getElementById('overlayText');
const textSize = document.getElementById('textSize');
const textColor = document.getElementById('textColor');
const textPos = document.getElementById('textPos');
const textBold = document.getElementById('textBold');
const rotateRange = document.getElementById('rotateRange');
const rotateValue = document.getElementById('rotateValue');
const flipH = document.getElementById('flipH');
const flipV = document.getElementById('flipV');
const flipReset = document.getElementById('flipReset');
const downloadSelectedSizesBtn = document.getElementById('downloadSelectedSizes');
const multiSizeStatus = document.getElementById('multiSizeStatus');
const sizeCheckboxes = document.querySelectorAll('.sizeOpt');
const resizeModeSel = document.getElementById('resizeMode');
const padColorInput = document.getElementById('padColor');
const usePadColor = document.getElementById('usePadColor');
let flipStateH = false;
let flipStateV = false;
// Track current text box pixel width (in image space approximate)
let textBoxClientWidth = null; // client CSS pixels of textarea
let lastSentTextBoxWidth = null;
let overlayBoxWidthPx = null; // width of dragged overlay in image pixels
const textRotateRange = document.getElementById('textRotateRange');

async function fetchAdjusted(){
    if(!processedImgEl || !resultFileName) return;
    const b = brightnessRange.value;
    const s = sharpnessRange.value;
    adjustStatus.textContent = 'Applying…';
    const needRender = currentBgColor || currentBgImage || (overlayText && overlayText.value.trim()) || (rotateRange && rotateRange.value !== '0') || (flipStateH || flipStateV);
    const baseEndpoint = needRender ? '/render' : '/adjust';
    let url = `${baseEndpoint}?file=${encodeURIComponent(resultFileName)}&brightness=${b}&sharpness=${s}`;
    if(currentBgColor){
        url += `&color=${encodeURIComponent(currentBgColor.replace('#',''))}`;
    }
    if(currentBgImage){
        url += `&bg_image=${encodeURIComponent(currentBgImage)}`;
    }
    if(overlayText && overlayText.value.trim()){
        url += `&text=${encodeURIComponent(overlayText.value)}`;
        url += `&text_size=${encodeURIComponent(textSize.value || '48')}`;
        url += `&text_color=${encodeURIComponent(textColor.value.replace('#',''))}`;
        url += `&text_pos=${encodeURIComponent(textPos.value)}`;
        if(textBold.checked) url += `&text_bold=1`;
        const wToSend = overlayBoxWidthPx || textBoxClientWidth;
        if(wToSend){
            url += `&text_box_w=${encodeURIComponent(wToSend)}`;
        }
        if(textAbsX !== null && textAbsY !== null){
            url += `&text_x=${textAbsX}&text_y=${textAbsY}`;
        }
        if(textRotateRange && textRotateRange.value !== '0'){
            url += `&text_rotate=${encodeURIComponent(textRotateRange.value)}`;
        }
    }
    if(rotateRange && rotateRange.value !== '0'){
        url += `&rotate=${encodeURIComponent(rotateRange.value)}`;
    }
        if(textRotateRange && textRotateRange.value !== '0' && !(overlayText && overlayText.value.trim())){
            // if user rotates text but no text, ignore
        }
    let flipParam = '';
    if(flipStateH) flipParam += 'h';
    if(flipStateV) flipParam += 'v';
    if(flipParam) url += `&flip=${flipParam}`;
    try {
        const resp = await fetch(url);
        if(!resp.ok) throw new Error('HTTP '+resp.status);
        const blob = await resp.blob();
        const objURL = URL.createObjectURL(blob);
        processedImgEl.src = objURL;
        adjustStatus.textContent = `B ${b} | S ${s}` + (currentBgColor ? ` | BG color` : (currentBgImage ? ' | BG image' : ''));
    } catch(err){
        adjustStatus.textContent = 'Error: '+err.message;
    }
}

if (brightnessRange && sharpnessRange){
    let debounceTimer;
    const handler = () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(fetchAdjusted, 180);
    };
    brightnessRange.addEventListener('input', handler);
    sharpnessRange.addEventListener('input', handler);
}

if (resetAdjust){
    resetAdjust.addEventListener('click', () => {
        if(!brightnessRange || !sharpnessRange) return;
        brightnessRange.value = 1;
        sharpnessRange.value = 1;
    currentBgColor = '';
    currentBgImage = '';
    removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
}

function ensurePlaceholder(col, id, text){
    let el = document.getElementById(id);
    if(!el){
        el = document.createElement('div');
        el.id = id;
        el.className = 'placeholder';
        el.textContent = text;
        col.appendChild(el);
    } else {
        el.style.display='block';
    }
}

function resetForNewSelection(){
    // Remove server original image
    const serverOriginal = document.getElementById('serverOriginalImg');
    if(serverOriginal) serverOriginal.remove();
    // Remove processed image & download link
    const processedImg = document.getElementById('processedImg');
    if(processedImg) processedImg.remove();
    const downloadLinkWrapper = processedCol.querySelector('.download');
    if(downloadLinkWrapper) downloadLinkWrapper.remove();
    // Recreate / show placeholders
    ensurePlaceholder(originalCol, 'originalPlaceholder', 'No image selected');
    ensurePlaceholder(processedCol, 'processedPlaceholder', 'Process to see result');
    // Hide instant preview until change event loads new image
    instantImg.style.display='none';
}

fileInput.addEventListener('change', function(){
    const file = this.files && this.files[0];
    if(!file){ instantImg.style.display='none'; return; }
    const reader = new FileReader();
    reader.onload = e => {
        instantImg.src = e.target.result;
        instantImg.style.display = 'block';
        if (originalPlaceholder) originalPlaceholder.remove();
        if (!originalCol.querySelector('#instantOriginalImg')) {
            originalCol.appendChild(instantImg);
        }
    };
    reader.readAsDataURL(file);
});

// Reset everything on click (before file chooser opens)
fileInput.addEventListener('click', resetForNewSelection);

// Hide instant preview if a server-rendered Original Image exists
if (document.querySelector('img[alt="Original Image"]')) {
    instantImg.style.display='none';
}

// Enable downloading the currently adjusted version instead of the original processed file
if (downloadProcessed && processedImgEl){
    downloadProcessed.addEventListener('click', async (e) => {
        if(!resultFileName || !brightnessRange || !sharpnessRange) return; // fallback to normal href
        e.preventDefault();
        // Fetch current adjusted image (ensuring latest slider values are applied)
        const b = brightnessRange.value;
        const s = sharpnessRange.value;
        const baseEndpoint = (currentBgColor || currentBgImage || (overlayText && overlayText.value.trim()) || (rotateRange && rotateRange.value !== '0') || (flipStateH || flipStateV)) ? '/render' : '/adjust';
        let url = `${baseEndpoint}?file=${encodeURIComponent(resultFileName)}&brightness=${b}&sharpness=${s}`;
        if(currentBgColor){
            url += `&color=${encodeURIComponent(currentBgColor.replace('#',''))}`;
        }
        if(currentBgImage){
            url += `&bg_image=${encodeURIComponent(currentBgImage)}`;
        }
        if(overlayText && overlayText.value.trim()){
            url += `&text=${encodeURIComponent(overlayText.value)}`;
            url += `&text_size=${encodeURIComponent(textSize.value || '48')}`;
            url += `&text_color=${encodeURIComponent(textColor.value.replace('#',''))}`;
            url += `&text_pos=${encodeURIComponent(textPos.value)}`;
            if(textBold.checked) url += `&text_bold=1`;
            const wToSend = overlayBoxWidthPx || textBoxClientWidth;
            if(wToSend){
                url += `&text_box_w=${encodeURIComponent(wToSend)}`;
            }
            if(textAbsX !== null && textAbsY !== null){
                url += `&text_x=${textAbsX}&text_y=${textAbsY}`;
            }
            if(textRotateRange && textRotateRange.value !== '0'){
                url += `&text_rotate=${encodeURIComponent(textRotateRange.value)}`;
            }
        }
        if(rotateRange && rotateRange.value !== '0'){
            url += `&rotate=${encodeURIComponent(rotateRange.value)}`;
        }
        let flipParam = '';
        if(flipStateH) flipParam += 'h';
        if(flipStateV) flipParam += 'v';
        if(flipParam) url += `&flip=${flipParam}`;
        try {
            const resp = await fetch(url);
            if(!resp.ok) throw new Error('HTTP '+resp.status);
            const blob = await resp.blob();
            const a = document.createElement('a');
            const objectUrl = URL.createObjectURL(blob);
            a.href = objectUrl;
            const base = resultFileName.replace(/\.png$/i,'');
            const bSan = b.replace(/[^0-9.]/g,'');
            const sSan = s.replace(/[^0-9.]/g,'');
            const bgTag = currentBgColor ? `_bg${currentBgColor.replace('#','')}` : (currentBgImage ? `_bgimg` : '');
            let textTag = overlayText && overlayText.value.trim() ? '_txt' : '';
            let rotTag = rotateRange && rotateRange.value !== '0' ? `_r${rotateRange.value}` : '';
            let flipTag = flipParam ? `_f${flipParam}` : '';
            a.download = `${base}_b${bSan}_s${sSan}${bgTag}${textTag}${rotTag}${flipTag}.png`;
            document.body.appendChild(a);
            a.click();
            setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); }, 1500);
        } catch(err){
            console.error('Download failed', err);
        }
    });
}

// Background color swatches
swatches.forEach(btn => {
    btn.addEventListener('click', () => {
        currentBgColor = btn.getAttribute('data-color');
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
});

if(customColor){
    customColor.addEventListener('input', () => {
        currentBgColor = customColor.value;
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
}

if(clearBgBtn){
    clearBgBtn.addEventListener('click', () => {
        currentBgColor = '';
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        if(overlayText) overlayText.value='';
        if(textSize) textSize.value='48';
        if(textColor) textColor.value='#000000';
        if(textPos) textPos.value='bc';
        if(textBold) textBold.checked=false;
        if(rotateRange){ rotateRange.value=0; rotateValue.textContent='0°'; }
        flipStateH=false; flipStateV=false;
    textAbsX = textAbsY = null;
    removeDragText();
        fetchAdjusted();
    });
}
function ensureDragText(){
    if(!overlayText || !overlayText.value.trim()) { removeDragText(); return; }
    if(!dragTextEl){
        dragTextEl = document.createElement('div');
        dragTextEl.id = 'dragOverlayText';
        dragTextEl.style.position = 'absolute';
        dragTextEl.style.left = '50%';
        dragTextEl.style.top = '90%';
        dragTextEl.style.transform = 'translate(-50%, -50%)';
        dragTextEl.style.cursor = 'move';
        dragTextEl.style.userSelect = 'none';
        dragTextEl.style.padding = '2px 4px';
        dragTextEl.style.background = 'rgba(255,255,255,0.2)';
        dragTextEl.style.border = '1px dashed #555';
        dragTextEl.style.fontFamily = 'sans-serif';
        dragTextEl.style.fontWeight = textBold.checked ? '700':'400';
        dragTextEl.style.fontSize = (textSize.value||48)+ 'px';
        dragTextEl.style.color = textColor.value;
        const containerParent = processedImgEl.parentElement;
        containerParent.style.position='relative';
        containerParent.appendChild(dragTextEl);
    }
    dragTextEl.textContent = overlayText.value; // preserve newlines
    dragTextEl.style.fontWeight = textBold.checked ? '700':'400';
    dragTextEl.style.fontSize = (textSize.value||48)+ 'px';
    dragTextEl.style.color = textColor.value;
    dragTextEl.style.whiteSpace = 'pre-wrap';
    dragTextEl.style.maxWidth = processedImgEl ? processedImgEl.clientWidth + 'px' : '100%';
}

function removeDragText(){
    if(dragTextEl){
        dragTextEl.remove();
        dragTextEl = null;
    }
}

function imagePixelFromClient(clientX, clientY){
    const rect = processedImgEl.getBoundingClientRect();
    const scaleX = processedImgEl.naturalWidth / rect.width;
    const scaleY = processedImgEl.naturalHeight / rect.height;
    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;
    return {x: Math.round(x), y: Math.round(y)};
}

function startDrag(e){
    if(!dragTextEl) return;
    dragging = true;
    const rect = dragTextEl.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', endDrag);
    e.preventDefault();
}
function onDragMove(e){
    if(!dragging || !dragTextEl) return;
    const parentRect = processedImgEl.getBoundingClientRect();
    let left = e.clientX - dragOffsetX - parentRect.left;
    let top = e.clientY - dragOffsetY - parentRect.top;
    // constrain within image box
    left = Math.max(0, Math.min(parentRect.width - dragTextEl.offsetWidth, left));
    top = Math.max(0, Math.min(parentRect.height - dragTextEl.offsetHeight, top));
    dragTextEl.style.left = left + 'px';
    dragTextEl.style.top = top + 'px';
    dragTextEl.style.transform = 'translate(0,0)';
}
function endDrag(e){
    if(!dragging) return;
    dragging = false;
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', endDrag);
    if(dragTextEl){
    const rect = dragTextEl.getBoundingClientRect();
    const imgRect = processedImgEl.getBoundingClientRect();
    const scaleX = processedImgEl.naturalWidth / imgRect.width;
    const scaleY = processedImgEl.naturalHeight / imgRect.height;
    const left = rect.left - imgRect.left;
    const top = rect.top - imgRect.top;
    textAbsX = Math.round(left * scaleX);
    textAbsY = Math.round(top * scaleY);
    const padAdjust = 8; // 2px 4px padding
    overlayBoxWidthPx = Math.max(10, Math.round((rect.width - padAdjust) * scaleX));
    fetchAdjusted();
    }
}

// Event bindings for drag
document.addEventListener('mousedown', (e)=>{
    if(e.target === dragTextEl){
        startDrag(e);
    }
});

// Update drag overlay on text-related input changes
[overlayText, textSize, textColor, textBold].forEach(el => {
    if(!el) return;
    el.addEventListener('input', () => { 
        // Reset absolute placement if text characteristics changed
        textAbsX = textAbsY = null; 
        ensureDragText(); 
        fetchAdjusted(); 
    });
    el.addEventListener('change', () => { 
        textAbsX = textAbsY = null; 
        ensureDragText(); 
        fetchAdjusted(); 
    });
});
if(textPos){
    textPos.addEventListener('change', () => { 
        // Changing preset resets manual coordinates
        textAbsX = textAbsY = null; 
        ensureDragText(); 
        fetchAdjusted(); 
    });
}
if(textRotateRange){
    textRotateRange.addEventListener('input', () => { fetchAdjusted(); });
}

// Initialize existing text if any after load
window.addEventListener('load', ()=>{ ensureDragText(); });

// Observe textarea width changes (manual resize) to re-render when baked next time
if(overlayText){
    const resizeObserver = new ResizeObserver(entries => {
        for(const entry of entries){
            const w = Math.round(entry.contentRect.width);
            if(w !== textBoxClientWidth){
                textBoxClientWidth = w;
                // If text already baked (coords set) trigger re-render to apply wrapping.
                if(textAbsX !== null && textAbsY !== null){
                    fetchAdjusted();
                }
            }
        }
    });
    resizeObserver.observe(overlayText);
    // Initial width capture
    textBoxClientWidth = Math.round(overlayText.getBoundingClientRect().width);
}

// Upload custom background image
if(bgImageInput){
    bgImageInput.addEventListener('change', async () => {
        const file = bgImageInput.files && bgImageInput.files[0];
        if(!file) return;
        const formData = new FormData();
        formData.append('bg', file);
        bgUploadStatus.textContent = 'Uploading...';
        try {
            const resp = await fetch('/upload_bg', { method: 'POST', body: formData });
            const data = await resp.json();
            if(!resp.ok){
                throw new Error(data.error || resp.status);
            }
            currentBgImage = data.filename;
            currentBgColor = '';
            removeBgImageBtn.style.display='inline-block';
            bgUploadStatus.textContent = 'BG image set';
            fetchAdjusted();
        } catch(err){
            bgUploadStatus.textContent = 'Error';
            console.error(err);
        }
    });
}

if(removeBgImageBtn){
    removeBgImageBtn.addEventListener('click', () => {
        currentBgImage = '';
        removeBgImageBtn.style.display='none';
        fetchAdjusted();
    });
}

if(rotateRange){
    rotateRange.addEventListener('input', () => {
        rotateValue.textContent = rotateRange.value + '°';
        fetchAdjusted();
    });
}

if(flipH){
    flipH.addEventListener('click', () => { flipStateH = !flipStateH; fetchAdjusted(); });
}
if(flipV){
    flipV.addEventListener('click', () => { flipStateV = !flipStateV; fetchAdjusted(); });
}
if(flipReset){
    flipReset.addEventListener('click', () => { flipStateH=false; flipStateV=false; fetchAdjusted(); });
}

if(downloadSelectedSizesBtn){
    downloadSelectedSizesBtn.addEventListener('click', async () => {
        if(!resultFileName){ multiSizeStatus.textContent='No image'; return; }
        const selected = Array.from(sizeCheckboxes).filter(c=>c.checked).map(c=>c.value);
        if(selected.length===0){ multiSizeStatus.textContent='Select sizes'; return; }
        multiSizeStatus.textContent='Building…';
        // Base params replicate fetchAdjusted logic
        const b = brightnessRange.value;
        const s = sharpnessRange.value;
    let url = `/multi_resize?file=${encodeURIComponent(resultFileName)}&brightness=${b}&sharpness=${s}&sizes=${selected.join(',')}`;
    if(resizeModeSel){ url += `&mode=${encodeURIComponent(resizeModeSel.value)}`; }
    if(usePadColor && usePadColor.checked && padColorInput){ url += `&pad=${encodeURIComponent(padColorInput.value.replace('#',''))}`; }
        if(currentBgColor){ url += `&color=${encodeURIComponent(currentBgColor.replace('#',''))}`; }
        if(currentBgImage){ url += `&bg_image=${encodeURIComponent(currentBgImage)}`; }
        if(overlayText && overlayText.value.trim()){
            url += `&text=${encodeURIComponent(overlayText.value)}`;
            url += `&text_size=${encodeURIComponent(textSize.value || '48')}`;
            url += `&text_color=${encodeURIComponent(textColor.value.replace('#',''))}`;
            url += `&text_pos=${encodeURIComponent(textPos.value)}`;
            if(textBold.checked) url += `&text_bold=1`;
            const wToSend = overlayBoxWidthPx || textBoxClientWidth;
            if(wToSend){ url += `&text_box_w=${encodeURIComponent(wToSend)}`; }
            if(textAbsX !== null && textAbsY !== null){ url += `&text_x=${textAbsX}&text_y=${textAbsY}`; }
            if(textRotateRange && textRotateRange.value !== '0'){ url += `&text_rotate=${encodeURIComponent(textRotateRange.value)}`; }
        }
        if(rotateRange && rotateRange.value !== '0'){ url += `&rotate=${encodeURIComponent(rotateRange.value)}`; }
        let flipParam='';
        if(flipStateH) flipParam+='h';
        if(flipStateV) flipParam+='v';
        if(flipParam) url += `&flip=${flipParam}`;
        try {
            const resp = await fetch(url);
            if(!resp.ok) throw new Error('HTTP '+resp.status);
            const blob = await resp.blob();
            const a = document.createElement('a');
            const obj = URL.createObjectURL(blob);
            a.href = obj;
            a.download = 'social_variants.zip';
            document.body.appendChild(a);
            a.click();
            setTimeout(()=>{ URL.revokeObjectURL(obj); a.remove(); }, 1500);
            multiSizeStatus.textContent='Done';
        } catch(err){
            multiSizeStatus.textContent='Error';
            console.error(err);
        }
    });
}
</script>
</body>
</html>
